\documentclass[a4paper]{article}

\usepackage[pdftex]{graphicx}
\usepackage{a4wide}
\usepackage{hyperref}
\usepackage{times}

% TODO: get UTF to work in biblio (Normunds' citation)
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}

\graphicspath{{./images/}}

\def\uid#1{\texttt{#1}}
\def\xp#1{\texttt{#1}}
\newcommand\ace{Attempto Controlled English}

\begin{document}
\title{Attempto Controlled English in Grammatical Framework}
\author{DRAFT}

\hyphenation{alpha-numeric}
\hyphenation{ex-pe-ri-ment-al}

\maketitle
\begin{abstract}
This report describes the implementation of a large part of the
Attempto Controlled English (ACE) syntax ---
the subset of ACE that is accepted by the AceWiki semantic wiki system ---
in Grammatical Framework (GF) and making it available via [TODO: 10]
languages that are supported by the GF Resource Grammar Library (RGL).
As a result, ACE becomes available in multiple languages, making
ACE-based knowledge representation possible also in languages other than
English.
Additionally, the GF-based implementation of the ACE language provides
ACE users with new (GF-based) editing tools.
\end{abstract}

\section{Introduction}

\ace{} (ACE) \cite{fuchs:reasoningweb2008} is a controlled natural language
(CNL), concretely a general purpose
first-order language (FOL)
with English syntax,
i.e. ACE can be viewed as both a natural language understandable by every
English speaker, as well as a formal language with a precisely defined
syntax and semantics understandable by automatic theorem proving software.
ACE texts are deterministically interpreted
via Discourse Representation Structures (DRS) \cite{kamp:drt1993}.
The syntactically legal sentence structures and their
unambiguous interpretation is explained in the end-user documentation of
\emph{construction} and \emph{interpretation} rules.
The ACE toolchain includes a parser that maps ACE sentences into a concrete
DRS form \cite{ifi-2010.0010} and further into formats supported by existing
automatic reasoners (e.g. OWL, SWRL, TPTP).

The current version of ACE, version 6.6, offers many language constructs, most
important of which are
countable and mass nouns (`man', `water');
proper names (e.g. `John');
generalized quantifiers (e.g. `at least');
indefinite pronouns (e.g. `somebody');
intransitive, transitive and ditransitive verbs (`sleep', `like', `give');
negation, conjunction and disjunction of
noun phrases, verb phrases, relative clauses and sentences;
and anaphoric references to noun phrases through
definite noun phrases, pronouns, and variables.
End-users working with ACE can specify a lexicon that maps English
wordforms of nouns, verbs, adjectives and adverbs into logical atoms,
which the users
can interpret as they wish, but otherwise the ACE grammar or its mapping to
DRS cannot be changed.

The full ACE specification describes a language which goes beyond the semantic
expressivity of many popular knowledge representation languages. Therefore,
several subsets of ACE have been defined to allow for a more direct
bidirectional mapping to these languages. The most explicitly defined subset
is the language used in the AceWiki semantic wiki system
\cite{kuhn2010doctoralthesis}, which closely corresponds to the OWL ontology
language \cite{OWL_2_Web_Ontology_Language_Document_Overview}.

Grammatical Framework (GF) \cite{ranta:book2011}
is a framework for defining multilingual grammars.
GF provides a functional programming language in which
the grammar author implements an abstract grammar and its corresponding
concrete grammars and by doing that
describes a bidirectional mapping between concrete language strings and
their corresponding abstract syntax trees. This architecture supports
multilingual translation as strings of any concrete language can be parsed into
abstract trees which can be further linearized as strings in any concrete
language.

GF is an expressive formalism optimized to handle natural language features
like morphological variation, agreement, long-distance dependencies, etc.
GF comes with various tools that
cover grammar authoring, compatibility with many popular programming languages,
conversion into other grammar formats, and a reusable grammar library covering
many world natural languages and providing a language-neutral API to a large
number of linguistic categories (e.g. NP, VP) and constructs
(e.g. combination of NP and VP into a sentence).

The purpose of this report is to study whether it is possible and useful to
implement the grammar of ACE in GF, with the main goal of turning ACE into
a multilingual CNL.
In section \ref{section:Goals_and_requirements} we describe the goals and
requirements that a GF-based implementation of ACE should meet;
in section \ref{section:Existing_work} we point out existing implementations;
in section \ref{section:Implementing_ACE_in_GF} we describe our implementation;
in section \ref{section:Multilinguality} we describe the most important feature
of this implementation, namely multilinguality;
in section \ref{section:Evaluation} we evaluate the implementation by comparing
it to existing implementations of the ACE grammar and discuss the multilingual
representations of ACE sentences;
in section \ref{section:Future_work} we describe possible extensions to this
work.

The developed grammar as well as the test sets, development tools and
documentation are available under the LGPL license on the GitHub repository

\begin{quote}
\url{https://github.com/Attempto/ACE-in-GF}
\end{quote}

\section{Goals and requirements}
\label{section:Goals_and_requirements}

The overall goal of this work is to make ACE available to users who have little
English skills by turning ACE-based systems like
AceWiki \cite{kuhn2010doctoralthesis} multilingual. This allows users
to create and consume content whose native format is a formal language
(specifically a FOL-based language) in multiple natural languages
via an ACE-based interlingua (see figure \ref{fig:languages}).
Also, having a GF implementation of the ACE language would
provide ACE users with new (editing) tools that are based on the GF technology,
offering e.g. look-ahead editing, embeddable grammars, conversion into
speech recognition grammar formats, etc.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{languages}
\caption[Languages]
{Bidirectional mapping between a formal language like OWL and a natural
language like Finnish facilitated by the multilingual GF-implementation of
ACE and various mappings between ACE and other formal languages.}
\label{fig:languages}
\end{figure}

%Our main research questions are:
%
%\begin{itemize}
%\item what are the features and benefits of a general purpose multilingual
%controlled natural language?
%\item is it technically possible to implement the ACE syntax in GF,
%and what are the benefits of such an implementation?
%\end{itemize}

Our goal is to demonstrate that a large fragment of the ACE syntax
can be implemented in a language-neutral way and ported to a large number
of different natural languages (including ACE itself).
This involves showing that

\begin{itemize}
\item the ACE-language implementation in the resulting grammar matches
precisely the chosen ACE subset and can be parsed unambiguously;
\item the resulting grammar remains maintainable, i.e. extending and modifying
it to reflect possible changes in the ACE specification is straight-forward;
\item multilingual translations of the same abstract tree preserve the precise
and unambiguous meaning assigned to the ACE sentences by the ACE interpretation
rules;
\item adding support for new languages is straight-forward and requires little
extra work.
\end{itemize}

Note that this report describes the implementation of the ACE syntax,
i.e. not its DRS mapping. The latter is not necessary for the purposes of a
multilingual grammar. As most usages of ACE involve its DRS mapping, also
most usages of the our GF implementation
will have to combine it with the existing ACE parser, which provides the
mapping to DRS and further into other logical forms (including a verbalization
back into ACE which can be used to paraphrase the original text).


\section{Existing work}
\label{section:Existing_work}

Our work builds on \cite{ranta:cnl2009_revised} which implements the syntax
of ACE v6.0 (by following \cite{ACE_6.0_Construction_Rules}) and makes it
available in 7 languages (English, French, German, Italian, Swedish, Finnish
and Urdu) via the GF Resource Grammar Library (RGL) \cite{ranta:lilt2009}.
Our goal is to update this implementation to ACE v6.6, make it precisely
cover a large subset of ACE, and increase the number of natural languages to
which the grammar is ported.

Another existing work that implements ACE in GF is
``ACE compliant controlled Latvian for ontology authoring and verbalization''
\footnote{\url{http://valoda.ailab.lv/cnl/}}
\cite{gruzitis:phd}. The goal of this work is to bidirectionally map Latvian
language sentences to OWL axioms and queries. The developed system
does not expose ACE to the end-user and only treats it as a
machine-readable intermediate format that provides access to the ACE tools
(specifically the bidirectional OWL converter).
It therefore does not have to deal with the
generation of correct ACE wordforms.
The system is also not built with multilinguality in mind
(i.e. it does not use the general GF RGL APIs). It thus cannot serve easily as
a starting point of the work described in this report.


\section{Implementing ACE in GF}
\label{section:Implementing_ACE_in_GF}

Rather than directly building a grammar for the
full ACE v6.6\cite{ACE_6.6_Construction_Rules}, we chose to focus
on the subset of ACE that is used by the AceWiki semantic wiki system. The
resulting grammar can be seen as a core module which can be used by AceWiki
without any change and which can be extended by a separate grammar
towards full ACE as need arises. The AceWiki subset is a relatively expressive
fragment of ACE, roughly matching the expressivity of the OWL ontology
language
\cite{OWL_2_Web_Ontology_Language_Document_Overview}
without data properties.
This makes the subset relevant in (Semantic Web) ontology editing applications.
The other benefit of the AceWiki subset is that it is formally defined by a
Codeco grammar \cite{kuhn:cnl2010_revised}
\footnote{\url{http://attempto.ifi.uzh.ch/site/docs/acewikijava/ch/uzh/ifi/attempto/acewiki/aceowl/acewiki_grammar.html}},
which provides both parsing and generation and thus gives us an excellent
reference implementation against which we can easily test our GF-based
implementation.
With Codeco we can perform exhaustive generation of syntactically legal
sentences. Also the Codeco grammar can be used to implement look-ahead
editors, similarly to GF, which provides for us another point of comparison.

\subsection{Short comparison of Codeco and GF}
\label{subsection:Codeco}

Codeco is a unification grammar formalism with special support for describing
anaphoric references. For example, the following (simplified) rules

\small
\begin{quote}
\begin{verbatim}
simple_sentence => 'there is' np[pl:-, def:-, exist:+]
np[def:+] => 'the' noun[noun:Noun] <[type:noun, noun:Noun] >[type:ref]
\end{verbatim}
\end{quote}
\normalsize

declare that a simple
sentence can be formed by `there is' followed by
a noun phrase (NP) that is further restricted by the binary features of
plurality, definiteness and existential quantification.
A definite noun phrase (\verb!np[def:+]!) can be formed by prefixing
a noun with `the'. Such a noun phrase
must refer to a preceding (\verb!<!) noun phrase and can be referred to by a
following (\verb!>!) noun phrase provided that the feature structures
unify, e.g. nouns in the noun phrases match.
The definite NP cannot be used after `there is' because the
declared features \verb!def:+! and \verb!def:-! do not unify.

Most of the features are syntactic in nature and must be therefore implemented
in GF's concrete grammar which offers structures similar to Codeco's feature
sets and operations similar to Codeco's unification. However, some of the
features are semantic in nature (e.g. `exists') and should be therefore
implemented in GF's abstract grammar where such unification-style rules are
not possible. In neither case is a direct mapping of Codeco grammar rules
and features to a GF grammar functions and categories possible.
[TODO: go over the Codeco features and see what corresponds to them
in GF, if it should belong to the concrete or the abstract part.]

In the Codeco subset anaphoric references can be made via definite noun
phrases (`the man') and variables (`X'). In order for an anaphoric reference
to occur there must exist a declaration of an antecedent (`a man') which must
be syntactically accessible (by the Discourse Representation Theory rules)
to an anaphor (`the man'). This means that certain usages of definite NPs
and variables are illegal and should be captured by a precise parser, e.g.

\begin{itemize}
\item $\star$ every man likes the woman \hfill \\
(\emph{an antecedent is not declared})
\item $\star$ every man likes a woman and the woman is Mary \hfill \\
(\emph{an antecedent is not accessible})
\item $\star$ a man X likes a woman X \hfill \\
(\emph{an antecedent is redeclared})
\end{itemize}

As GF does not offer special support for describing anaphoric references
with their accessibility constraints, and trying to express such constraints
would make the grammar overly complicated,
we decided not to precisely model the ACE support for anaphoric references.
Our implementation covers the legal anaphoric constructions but additionally
fails to detect the illegal ones (e.g. the ones listed above).

\subsection{Structure}

Closely following the original implementation in \cite{ranta:cnl2009_revised},
the multilingual ACE grammar is implemented in GF as a set of modules
(see figure \ref{fig:modules}) the most important of which are:

\begin{itemize}
\item abstract syntax \texttt{Attempto} which defines the ACE syntax as
a set of $\sim$100 language-independent functions
(e.g. \verb!everyNP : CN -> NP!)
that operate on language-independent categories (\texttt{CN}, \texttt{NP});
\item incomplete concrete syntax \texttt{AttemptoI} which uses the GF RGL
to provide concrete linearizations for the abstract functions. This module
is language-independent in the sense that the linearizations are provided
via the RGL API which is common to all the languages that are supported by the
RGL;
\item (complete) concrete syntax \texttt{Attempto\textit{Lan}}, where
\textit{Lan} is a 3-letter language code of the concrete language. This
module instantiates \texttt{AttemptoI} with the concrete language, but
additionally offers the possibility of language-specific fine-tuning of the
linearizations assigned by \texttt{AttemptoI} or the implementation of
linearizations that are not given in \texttt{AttemptoI}.
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=0.99\textwidth]{modules}
\caption[Relations between the ACE grammar modules]
{Relations between the modules, using German (Ger) as an example
of one of the many concrete languages. To add support for a new language,
e.g. Dutch, one must implement three files:
\texttt{AttemptoDut}, which just
instantiates the functor \texttt{AttemptoI} with Dutch-specific resources
from the RGL;
\texttt{TestAttemptoDut}, which contains the domain lexicon; and
\texttt{LexAttemptoDut}, which implements the Dutch-specific resources that
do not come from the RGL. The implementation of the lexicon can also
rely on the resources (Dutch morphological paradigms) implemented
in the RGL.}
\label{fig:modules}
\end{figure}


This architecture makes it easy to plug in support for new languages ---
one only needs to implement \texttt{Attempto\textit{Lan}} for the new language
\textit{Lan}. If the new language has RGL support and \texttt{AttemptoI}
already provides most of the implementation, then
the new module \texttt{Attempto\textit{Lan}} will be just a couple of lines
long.
This architecture makes it also easy to extend the grammar towards full ACE.
One needs to implement a set of new modules which import the existing modules
and add additional functions and their linearizations, and possibly
redefine existing functions if they implement restrictions that are not
present in full ACE.


\subsection{Lexicon}

ACE makes a clear separation of lexicon and the rest of the syntax. The ACE
lexicon is a simple mapping of word forms to their corresponding lemmas, which
can be easily added and redefined by the users
\cite{ACE_6.6_Lexicon_Specification}. While the full ACE knows 27 types of
word forms (singular common noun, transitive verb, ...), the AceWiki subset
uses a smaller but also a slightly different set of lexical categories.

\begin{itemize}
\item proper name (with possible abbreviation and \emph{the}-prefix)
\item common noun (with singular and plural form)
\item noun in an \emph{of}-construct (e.g. `part', `child')
\item transitive verb (with 3rd singular, bare infinitive and past participle
forms)
\item transitive adjective (e.g. `fond of')
\end{itemize}

GF does not make a clear separation between words and the rest of the grammar.
Furthermore, words can be described by complex structures holding information
about their gender, case, discontinuity, depending on the language. Most of
this necessary complexity is hidden by the RGL, which operates with common
lexical categories (e.g. \texttt{PN}, \texttt{V2}) and common constructors
(e.g. \texttt{mkN} takes two strings as arguments, for the singular and plural
forms of the noun, an guesses the missing information (e.g. gender).
Most of the ACE lexical categories are supported by the RGL and the internal
representations of words can be generated using RGL operators.
Table \ref{mapping_acewiki_to_gf} shows the mapping of AceWiki categories
to GF RGL English operators.
[TODO: we have to ignore certain things, e.g.  the the-PNs?]

\begin{table}
\begin{center}
\caption{Mapping of AceWiki lexical categories
to GF RGL API categories and GF English
morphological paradigms. Underscore marks the omission of wordforms that
cannot occur in ACE but that are required by the GF RGL
operator.\protect\label{mapping_acewiki_to_gf}}
\begin{tabular}{ l l l }
\hline
AceWiki category & GF Cat & GF Eng oper \\
\hline
proper name & PN & \xp{mkPN john} \\
common noun & CN & \xp{mkCN (mkN sg pl)} \\
relational noun & CN & \xp{mkCN (mkN sg \_)} \\
transitive verb & V2 & \xp{mkV2 (mkV go goes \_ gone \_)} \\
transitive adjective & A2 & \xp{mkA2 (mkA fond) (mkPrep of)} \\
\hline
\end{tabular}
\end{center}
\end{table}

%Mapping the ACE lexical categories to GF RGL categories and morphological
%paradigms.
%[TODO: discuss variation]
%
%Table \ref{mapping_clex_to_gf} shows the mapping.
%
%\begin{table}
%\begin{center}
%\caption{Mapping of Clex to GF\protect\label{mapping_clex_to_gf}}
%\begin{tabular}{ r l l }
%\hline
%Clex & Cat & GF oper \\
%\hline
%\xp{noun\_mass} & MCN & \xp{mkCN (mkN ... (mkN ...))} \\
%\hline
%\end{tabular}
%\end{center}
%\end{table}

\subsection{Design decisions}

[TODO: the implementation follows the ACE grammar, assigning a function to
each grammar rule unless it is too specific to English, in which case it can
be implemented as an English-only variant.]

\subsection{Summary}

The result is a grammar module that covers the AceWiki subset and also
has a preliminary extension towards the full ACE.

Mapping an ACE grammar (such as the one described by Codeco) to a GF grammar
is non-trivial for the following reasons.

\begin{itemize}
\item ACE is written in the unification style vs. GF grammar is written
by separating the abstract syntax from the concrete
\item ACE offers support for anaphoric references (a feature present in most
logical rule and ontology languages) vs. GF does not provide similar support
\end{itemize}


\section{Multilinguality}
\label{section:Multilinguality}

The architecture described in the previous section makes adding support
for a new language relatively straight-forward provided that the language
is supported by the RGL. Adding a new language involves
implementing all the functions not present in \texttt{AttemptoI},
overriding the \texttt{AttemptoI} implementation for functions which would
otherwise deliver a semantically or pragmatically wrong linearization,
implementing the (small number of) operators that are not provided by the RGL,
and providing the domain vocabulary for the application.

We selected a number of RGL-supported languages to evaluate how easy it
is to add a new language in practice and to evaluate the feasibility of
representing the language ACE in a language other than ACE. The chosen
languages are
English, German, Finnish, Urdu, Italian, French, Swedish, Dutch
(, Hindi, Spanish, Catalan?). [TODO: why these languages]

\subsection{ACE}

ACE was implemented by extending the English resource grammar but
overriding some of its constructs and adding some variants.

Does it make sense to treat ACE and English as separate languages in the
grammar, and expose them as different languages to the end user?

\subsection{Main issues}

[TODO: currently copied from \cite{ranta:cnl2009_revised}]
The translation from one language to another using the abstract syntax of the
resource grammar preserves syntactic structure. But it does not always give
the intended result. [TODO: ACE-specific example]
Thus the resource grammar should rather be used as a \emph{library} for
defining the domain grammar. In those cases where direct syntax-based
translation still works (which in practice does cover most cases), a lot of
work can be saved, because the linearization function for a given abstract
function can then be defined once and for all using the language-independent
API of the resource library. Some exceptions to this can then be done for
those languages that do not preserve syntactic structure in translation,
but still using the library. [TODO: example]

Some issues: RGL does not provide some functions for all the languages,
e.g. VP coordination.

\section{Evaluation}
\label{section:Evaluation}

In order to measure the quality of the grammar we can evaluate the following
properties.

\begin{description}
\item[Coverage]
i.e. how many syntactically correct ACE sentences does the grammar accept.
High coverage is required in applications which must translate a large variety
of ACE sentences. The goal is to have a 100\% coverage of the AceWiki subset.

\item[Ambiguity]
i.e. how many abstract trees are assigned on average to an accepted ACE
sentence. The goal is to parse each ACE sentence into to a single abstract
tree. However, some ambiguity can be tolerated if it is visible only internally,
it does not result in multiple different translations.

\item[Precision]
i.e. how many syntactically incorrect ACE sentences does the grammar generate.
Over-generation is especially undesired in the context of look-ahead editing
\cite{schwitter:eamt-claw2003}, where users would be exposed to
forms which the actual language does not support.

\item[Multilingual correctness]
i.e. do the translations of ACE sentences into other languages keep the
intended meaning of the original ACE sentences. Multilingual correctness allows
for knowledge engineering applications where users read and edit the underlying
knowledge-base in multiple languages, understanding its content in the same
way regardless of the language.

\item[Performance]
i.e. how fast is the parser/linearizer. A certain speed is required to embed
parsing and linearization into a user interface component, e.g. a look-ahead
editor.
\end{description}

In the following we mainly measure the grammar against the existing
Codeco grammar, but sometimes also against the full ACE parser APE.

\subsection{Syntactic coverage}

In order to test the syntactic coverage of the GF implementation of the
AceWiki subset we have used the AceWiki Codeco test set which
is an exhaustive set of sentences with length of up to 10
tokens \cite{kuhn2010doctoralthesis}. Each word
type is represented by a single word (e.g. `Mary' represents the proper name)
to make sure that all the sentences are pairwise syntactically different, i.e.
do not differ only by choice of words.
The original testset contains 19718 sentences, we removed sentences which
contain the `such that' construct which in ACE v6.6 is deprecated,
arriving at our test set of 19422 sentences.

[TODO: our implementation achieves X\% coverage, the remaining sentences
cannot be parsed because ...]

The AceWiki-specific implementation covers $\sim$50\% of full ACE, measured
on the $\sim$3000 sentences of the ACE parser (APE) regression test set.
(Note that these are sentences and text snippets manually collected over
several years, as APE does not support exhaustive generation.)

\subsection{Syntactic precision}

To test the precision (i.e. possible over-generation) we have used the
random generation facility of the GF commandline tool
(\verb!generate_random!). This allows us to randomly generate abstract trees
given the shape of the tree, its depth and its category. A resulting tree
can be then linearized as an ACE string which can be parsed with a
reference ACE parser.
This way of measuring precision is somewhat unnatural as one cannot gradually
go from shorter to longer sentences --- at relatively low depths the
sentences become already so long and complex that checking them for the
sources of errors becomes cumbersome.

The evaluation ignores the illegal anaphoric references as these are not
modelled as discussed in section \ref{subsection:Codeco}.

[TODO: other interesting cases?]

There are also
places where the AceWiki subset could be extended (rather that its GF
implementation restricted), e.g. AceWiki currently rejects ``every man
likes less than 3 men that own a cat.'' because an NP with a
generalized quantifier (less than 3) cannot be followed by a relative
clause. But this sentence is supported by the ACE-OWL translator
so there is no real reason why it should not be allowed in the
AceWiki subset.

% AceWiki does support: ``... that Mary likes``
Also, support for object relative clauses (``.. that Mary is mad-about'')
is desirable (even though AceWiki does not completely support it).

% AceWiki does not support: who does Mary (not) like?
% (only: Mary likes (does not like) who?)

\subsection{Ambiguity}

[TODO: does the grammar sometimes assign multiple trees to a sentence?]

\subsection{Multilinguality}

[TODO: this test can not be automated]

To test the correctness of the multilingual translations we have used
the sentences from the
Ontograph
Framework\footnote{\url{http://attempto.ifi.uzh.ch/site/docs/ontograph/}}
\cite{kuhn2009cnlmain}. These sentences cover all the main sentence
patters of the AceWiki subset and they have been used before in user
evaluations of how well the users understand the precise formal meaning
of the sentences.
These 40 sentences cover all the main AceWiki sentence patterns and have
a very clear set-theoretic meaning, e.g.
``Everything that is a traveler or that is an officer sees
at most 1 aquarium.'' means that the union of the sets \emph{traveler} and
\emph{officer} is a subset of the set of all instances that participate in
the 1st argument position in at most one \emph{sees}-relation with an
instance from the set \emph{aquarium}.
The question is if this meaning is understood in the same way via all the
languages.

[TODO: We did a closer evaluation of 7 languages.]

[TODO: VPCoord is not supported in all languages]

[TODO: interesting examples where the straight-forward translation produces
a completely different meaning]

[TODO: the Ontograph test set does not cover some core ACE equivalences,
e.g. \emph{if-then} equals \emph{every}, double negation equals no negation.
How are these equivalences preserved under the direct syntax-based
translation?]

\subsection{Performance}

We measured the performance of the grammar implementation on an i3 laptop
with 4GB of RAM.
The implementation is relatively fast. It is capable of parsing
all the $\sim$20,000 Codeco test sentences in 55 seconds
(i.e. 363 sentences/sec). In comparison, the Codeco DCG implementation parses
the same set in 25 seconds.
In order to linearize the
resulting parse trees into 8 languages an additional 9 minutes is needed
(Note that we did not measure what was
the contribution of each language to the overall runtime.)
Such performance enables applications where a relatively large ACE knowledge
base is stored as a set of GF abstract trees and linearized into a
multilingual presentation on demand in a few minutes.


\section{Future work}
\label{section:Future_work}

In the
future, one might want to extend the implementation (using
the standard GF extension mechanism) to also cover full ACE.

\bibliography{bib}
\bibliographystyle{alpha}
%\bibliographystyle{plain}

\end{document}
