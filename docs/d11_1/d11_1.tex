\documentclass[a4paper]{article}

\usepackage[pdftex]{graphicx}
\usepackage{a4wide}
\usepackage{hyperref}
\usepackage{times}

% TODO: get UTF to work in biblio (Normunds' citation)
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}

\graphicspath{{./images/}}

\def\uid#1{\texttt{#1}}
\def\xp#1{\texttt{#1}}
\newcommand\ace{Attempto Controlled English}

\begin{document}
\title{Attempto Controlled English in Grammatical Framework}
\author{DRAFT}

\hyphenation{alpha-numeric}
\hyphenation{ex-pe-ri-ment-al}

\maketitle
\begin{abstract}
This report describes the implementation of a large part of the
Attempto Controlled English (ACE) syntax ---
the subset of ACE that is accepted by the AceWiki semantic wiki system ---
in Grammatical Framework (GF) and making it available via 10
languages that are supported by the GF Resource Grammar Library (RGL).
As a result, ACE becomes available in multiple languages, making
ACE-based knowledge representation possible also in languages other than
English.
Additionally, the GF-based implementation of the ACE language provides
ACE users with new (GF-based) editing tools.
\end{abstract}

\section{Introduction}

\ace{} (ACE) \cite{fuchs:reasoningweb2008} is a controlled natural language
(CNL), concretely a general purpose
first-order language (FOL)
with English syntax,
i.e. ACE can be viewed as both a natural language understandable by every
English speaker, as well as a formal language with a precisely defined
syntax and semantics understandable by automatic theorem proving software.
ACE texts are deterministically interpreted
via Discourse Representation Structures (DRS) \cite{kamp:drt1993}.
The syntactically legal sentence structures and their
unambiguous interpretation are explained in the end-user documentation of
\emph{construction} and \emph{interpretation} rules.
The ACE toolchain includes a parser that maps ACE sentences into a concrete
DRS form \cite{ifi-2010.0010} and further into formats supported by existing
automatic reasoners (e.g. OWL, SWRL, TPTP).

The current version of ACE, version 6.6, offers many language constructs, most
important of which are
countable and mass nouns (`man', `water');
proper names (e.g. `John');
generalized quantifiers (e.g. `at least');
indefinite pronouns (e.g. `somebody');
intransitive, transitive and ditransitive verbs (`sleep', `like', `give');
negation, conjunction and disjunction of
noun phrases, verb phrases, relative clauses and sentences;
and anaphoric references to noun phrases through
definite noun phrases, pronouns, and variables.
End-users working with ACE can specify a lexicon that maps English
wordforms of nouns, verbs, adjectives and adverbs into logical atoms,
which the users
can interpret as they wish, but otherwise the ACE grammar or its mapping to
DRS cannot be changed.

The full ACE specification describes a language which goes beyond the semantic
expressivity of many popular knowledge representation languages. Therefore,
several subsets of ACE have been defined to allow for a more direct
bidirectional mapping to these languages. The most explicitly defined subset
is the language used in the AceWiki semantic wiki system
\cite{kuhn2010doctoralthesis}, which closely corresponds to the OWL ontology
language \cite{OWL_2_Web_Ontology_Language_Document_Overview}.

Grammatical Framework (GF) \cite{ranta:book2011}
is a framework for defining multilingual grammars.
GF provides a functional programming language in which
the grammar author implements an abstract grammar and its corresponding
concrete grammars and by doing that
describes a bidirectional mapping between concrete language strings and
their corresponding abstract syntax trees. This architecture supports
multilingual translation as strings of any concrete language can be parsed into
abstract trees which can be further linearized as strings in any concrete
language.

GF is an expressive formalism optimized to handle natural language features
like morphological variation, agreement, long-distance dependencies, etc.
GF comes with various tools that
cover grammar authoring, compatibility with many popular programming languages,
conversion into other grammar formats, and a reusable grammar library covering
many world natural languages and providing a language-neutral API to a large
number of linguistic categories (e.g. NP, VP) and constructs
(e.g. combination of NP and VP into a sentence).

The purpose of this report is to study whether it is possible and useful to
implement the grammar of ACE in GF, with the main goal of turning ACE into
a multilingual CNL.
In section \ref{section:Goals_and_requirements} we describe the goals and
requirements that a GF-based implementation of ACE should meet;
in section \ref{section:Existing_work} we point out two existing
GF implementations of ACE;
in section \ref{section:ACE_in_GF} we describe our implementation;
in section \ref{section:Multilinguality} we describe the most important feature
of this implementation, namely multilinguality;
in section \ref{section:Evaluation} we evaluate the implementation by comparing
it to existing implementations of the ACE grammar and discuss the multilingual
representations of ACE sentences;
in section \ref{section:Conclusions} we summarize the work and
describe its possible extensions.

The developed grammar as well as the test sets, development tools and
documentation are available under the LGPL license on the GitHub repository

\begin{quote}
\url{https://github.com/Attempto/ACE-in-GF}
\end{quote}

\section{Goals and requirements}
\label{section:Goals_and_requirements}

The overall goal of this work is to make ACE available to users who have little
English skills by turning ACE-based systems like
AceWiki \cite{kuhn2010doctoralthesis} multilingual. This allows users
to create and consume content whose native format is a formal language
(specifically a FOL-based language) in multiple natural languages
via an ACE-based interlingua (see figure \ref{fig:languages}).
Also, having a GF implementation of the ACE language would
provide ACE users with new (editing) tools that are based on the GF technology,
offering e.g. look-ahead editing, embeddable grammars, conversion into
speech recognition grammar formats, etc.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{languages}
\caption[Languages]
{Bidirectional mapping between a formal language like OWL and a natural
language like Finnish facilitated by the multilingual GF-implementation of
ACE and various mappings between ACE and other formal languages.}
\label{fig:languages}
\end{figure}

%Our main research questions are:
%
%\begin{itemize}
%\item what are the features and benefits of a general purpose multilingual
%controlled natural language?
%\item is it technically possible to implement the ACE syntax in GF,
%and what are the benefits of such an implementation?
%\end{itemize}

Our goal is to demonstrate that a large fragment of the ACE syntax
can be implemented in a language-neutral way and ported to a large number
of different natural languages (including ACE itself).
This involves showing that

\begin{itemize}
\item the ACE-language implementation in the resulting grammar matches
precisely the chosen ACE subset and can be parsed unambiguously;
\item the resulting grammar remains maintainable, i.e. extending and modifying
it to reflect possible changes in the ACE specification is straight-forward;
\item multilingual translations of the same abstract tree preserve the precise
and unambiguous meaning assigned to the ACE sentences by the ACE interpretation
rules;
\item adding support for new languages is straight-forward and requires little
extra work.
\end{itemize}

Note that this report describes the implementation of the ACE syntax,
i.e. not its DRS mapping. The latter is not necessary for the purposes of a
multilingual grammar. As most usages of ACE involve its DRS mapping, also
most usages of the our GF implementation
will have to combine it with the existing ACE parser, which provides the
mapping to DRS and further into other logical forms (including a verbalization
back into ACE which can be used to paraphrase the original text).


\section{Existing work}
\label{section:Existing_work}

Our work builds on \cite{ranta:cnl2009_revised} which implements the syntax
of ACE v6.0 (by following \cite{ACE_6.0_Construction_Rules}) and makes it
available in 7 languages (English, French, German, Italian, Swedish, Finnish
and Urdu) via the GF Resource Grammar Library (RGL) \cite{ranta:lilt2009}.
Our goal is to update this implementation to ACE v6.6, make it precisely
cover a large subset of ACE, and increase the number of natural languages to
which the grammar is ported.

Another existing work that implements ACE in GF is
``ACE compliant controlled Latvian for ontology authoring and verbalization''
\footnote{\url{http://valoda.ailab.lv/cnl/}}
\cite{gruzitis:phd}. The goal of this work is to bidirectionally map Latvian
language sentences to OWL axioms and queries. The developed system
does not expose ACE to the end-user and only treats it as a
machine-readable intermediate format that provides access to the ACE tools
(specifically the bidirectional OWL converter).
It therefore does not have to deal with the
generation of correct ACE wordforms.
The system is also not built with multilinguality in mind
(i.e. it does not use the general GF RGL APIs). It thus cannot serve easily as
a starting point of the work described in this report.


\section{Implementation of ACE in GF}
\label{section:ACE_in_GF}

Rather than directly building a grammar for the
full ACE v6.6\cite{ACE_6.6_Construction_Rules}, we chose to focus
on the subset of ACE that is used by the AceWiki semantic wiki system. The
resulting grammar can be seen as a core module which can be used by AceWiki
without any change and which can be extended by a separate grammar
towards full ACE as need arises. The AceWiki subset is a relatively expressive
fragment of ACE, roughly matching the expressivity of the OWL ontology
language
\cite{OWL_2_Web_Ontology_Language_Document_Overview}
without data properties.
This makes the subset relevant in (Semantic Web) ontology editing applications.
The other benefit of the AceWiki subset is that it is formally defined by a
Codeco grammar \cite{kuhn:cnl2010_revised}
\footnote{\url{http://attempto.ifi.uzh.ch/site/docs/acewikijava/ch/uzh/ifi/attempto/acewiki/aceowl/acewiki_grammar.html}},
which provides both parsing and generation and thus gives us an excellent
reference implementation against which we can easily test our GF-based
implementation.
With Codeco we can perform exhaustive generation of syntactically legal
sentences. Also the Codeco grammar can be used to implement look-ahead
editors, similarly to GF, which provides for us another point of comparison.

\subsection{Comparison of Codeco and GF}
\label{subsection:Codeco}

Codeco is a unification grammar formalism with special support for describing
anaphoric references. For example, the following (simplified) rules

\small
\begin{quote}
\begin{verbatim}
simple_sentence => 'there is' np[pl:-, def:-, exist:+]
np[def:+] => 'the' noun[noun:Noun] <[type:noun, noun:Noun] >[type:ref]
\end{verbatim}
\end{quote}
\normalsize

declare that a simple
sentence can be formed by `there is' followed by
a noun phrase (NP) that is further restricted by the binary features of
plurality, definiteness and existential quantification.
A definite noun phrase (\verb!np[def:+]!) can be formed by prefixing
a noun with `the'. Such a noun phrase
must refer to a preceding (\verb!<!) noun phrase and can be referred to by a
following (\verb!>!) noun phrase provided that the feature structures
unify, e.g. nouns in the noun phrases match.
The definite NP cannot be used after `there is' because the
declared features \verb!def:+! and \verb!def:-! do not unify.

Most of the Codeco features are syntactic in nature and therefore map to
GF's concrete grammar which offers structures similar to Codeco's feature
sets and operations similar to Codeco's unification. However, some of the
Codeco features are semantic in nature (e.g. `exists') and should be therefore
implemented in GF's abstract grammar where such unification-style rules are
not possible. In neither case is a direct mapping of Codeco grammar rules
and features to a GF grammar functions and categories possible.
[TODO: go over the Codeco features and see what corresponds to them
in GF, if it should belong to the concrete or the abstract part.]

In the Codeco subset anaphoric references can be made via definite noun
phrases (`the man') and variables (`X'). In order for an anaphoric reference
to occur there must exist a declaration of an antecedent (`a man') which must
be syntactically accessible (by the Discourse Representation Theory rules)
to an anaphor (`the man'). This means that certain usages of definite NPs
and variables are illegal and should be captured by a precise parser, e.g.

\begin{itemize}
\item $\star$ every man likes the woman \hfill \\
(\emph{an antecedent is not declared})
\item $\star$ every man likes a woman and the woman is Mary \hfill \\
(\emph{an antecedent is not accessible})
\item $\star$ a man X likes a woman X \hfill \\
(\emph{an antecedent is redeclared})
\end{itemize}

As GF does not offer special support for describing anaphoric references
with their accessibility constraints, and trying to express such constraints
would make the grammar overly complicated,
we decided not to precisely model the ACE support for anaphoric references.
Our implementation covers the legal anaphoric constructions but additionally
fails to detect the illegal ones (e.g. the ones listed above).

\subsection{Grammar module structure}

We followed the main structure of the ACE-in-GF implementation developed
in \cite{ranta:cnl2009_revised} but separated it into two parts, one that
implements the AceWiki subset and the other that extends this implementation
towards full ACE. We did not further develop the full ACE implementation, the
extension serves for the time being as a placeholder that preserves the
original \cite{ranta:cnl2009_revised} implementation. We only focused on the
AceWiki subset for the reasons listed above.

The multilingual ACE grammar is implemented in GF as a set of modules
(see figure \ref{fig:modules}) the most important of which are:

\begin{itemize}
\item the abstract grammar \texttt{Attempto} which defines the ACE syntax as
a set of $\sim$100 language-independent functions
that operate on language-independent categories such as \texttt{CN},
\texttt{NP}, \texttt{S}, e.g.
\begin{itemize}
\item \verb!fun everyNP : CN -> NP!
\item \verb!fun if_thenS : S -> S -> S!
\end{itemize}

\item the incomplete concrete grammar \texttt{AttemptoI} which uses the GF RGL
to provide concrete linearizations for the abstract functions
This module
is language-independent in the sense that the linearizations are provided
via the RGL API which is common to all the languages that are supported by the
RGL. Examples of API calls are:
\begin{itemize}
\item \verb!lin everyNP = mkNP every_Det!
\item \verb!lin if_thenS = mkS if_then_Conj!
\end{itemize}

\item the (complete) concrete grammar \texttt{Attempto\textit{Lan}}, where
\textit{Lan} is a 3-letter language code of the concrete language. This
module instantiates \texttt{AttemptoI} with the concrete language, but
additionally offers the possibility of language-specific fine-tuning of the
linearizations assigned by \texttt{AttemptoI} or the implementation of
linearizations that are not given in \texttt{AttemptoI}.
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=0.99\textwidth]{modules}
\caption[Relations between the ACE grammar modules]
{Relations between the ACE grammar modules, using German (Ger) as an example
of one of the many concrete languages. To add support for a new language,
e.g. Dutch, one must implement three files:
\texttt{AttemptoDut}, which
instantiates the functor \texttt{AttemptoI} with Dutch-specific resources
from the RGL;
\texttt{TestAttemptoDut}, which contains the domain lexicon; and
\texttt{LexAttemptoDut}, which implements the Dutch-specific resources that
do not come from the RGL. The implementation of the lexicon can also
rely on the resources (Dutch morphological paradigms) implemented
in the RGL.}
\label{fig:modules}
\end{figure}

This architecture makes it easy to plug in support for new languages ---
one only needs to implement \texttt{Attempto\textit{Lan}} for the new language
\textit{Lan}. If the new language has RGL support and \texttt{AttemptoI}
already provides most of the implementation, then
the new module \texttt{Attempto\textit{Lan}} will be just a couple of lines
long.
This architecture makes it also easy to extend the grammar towards full ACE.
One needs to implement a set of new modules which import the existing modules
and add additional functions and their linearizations, and possibly
redefine existing functions if they implement restrictions that are not
present in full ACE.

The GF implementation follows the Codeco implementation, assigning a function
to each grammar rule unless it is too specific to ACE, in which case it
can be implemented as an ACE-only variant. [TODO: improve]
To correctly implement the ACE syntax, a new ACE-specific resource library
was created. For the most part it borrows all the operators from GF's English
resource library, but overrides certain constructions which in ACE have a
more specific form than in English, e.g. the ACE form for transitive
adjectives (`fond of') requires the preposition to be attached with
the hyphen (`fond-of'). The overall grammar thus treats ACE and English as
separate languages.

\subsection{Lexicon}

ACE makes a clear separation of lexicon and the rest of the syntax. The ACE
lexicon is a simple mapping of word forms to their corresponding lemmas, which
can be easily added and redefined by the users
\cite{ACE_6.6_Lexicon_Specification}. While the full ACE knows 27 types of
word forms (singular common noun, transitive verb, ...), the AceWiki subset
uses a smaller but also a slightly different set of lexical categories.

\begin{itemize}
\item proper name (with possible abbreviation and \emph{the}-prefix)
\item common noun (with singular and plural form)
\item noun in an \emph{of}-construct (e.g. `part', `child')
\item transitive verb (with 3rd singular, bare infinitive and past participle
forms)
\item transitive adjective (e.g. `fond of')
\end{itemize}

GF does not make a clear separation between words and the rest of the grammar.
Furthermore, words can be described by complex structures holding information
about their gender, case, discontinuity, depending on the language. Most of
this necessary complexity is hidden by the RGL, which operates with common
lexical categories (e.g. \texttt{PN}, \texttt{V2}), and common and ``smart''
constructors (e.g. the simplest form of \texttt{mkN} takes one string as an
argument,
interprets this as the singular form of the noun, and guesses the remaining
unspecified information, e.g. the plural form and the gender).
Most of the ACE lexical categories are directly supported by the RGL and the
internal representations of words can be generated using RGL operators.
Table \ref{mapping_acewiki_to_gf} shows the mapping of AceWiki categories
to GF RGL English operators.
[TODO: we have to ignore certain things, e.g.  the the-PNs?]

\begin{table}
\begin{center}
\caption{Mapping of AceWiki lexical categories
to GF RGL API categories and GF English
morphological paradigms. Underscore marks the omission of wordforms that
cannot occur in ACE but that are required by the GF RGL
operator.\protect\label{mapping_acewiki_to_gf}}
\begin{tabular}{ l l l }
\hline
AceWiki category & GF Cat & GF Eng oper \\
\hline
proper name & PN & \xp{mkPN john} \\
common noun & CN & \xp{mkCN (mkN sg pl)} \\
relational noun & CN & \xp{mkCN (mkN sg \_)} \\
transitive verb & V2 & \xp{mkV2 (mkV go goes \_ gone \_)} \\
transitive adjective & A2 & \xp{mkA2 (mkA fond) (mkPrep of)} \\
\hline
\end{tabular}
\end{center}
\end{table}

%Mapping the ACE lexical categories to GF RGL categories and morphological
%paradigms.
%[TODO: discuss variation]
%
%Table \ref{mapping_clex_to_gf} shows the mapping.
%
%\begin{table}
%\begin{center}
%\caption{Mapping of Clex to GF\protect\label{mapping_clex_to_gf}}
%\begin{tabular}{ r l l }
%\hline
%Clex & Cat & GF oper \\
%\hline
%\xp{noun\_mass} & MCN & \xp{mkCN (mkN ... (mkN ...))} \\
%\hline
%\end{tabular}
%\end{center}
%\end{table}


\section{Multilinguality}
\label{section:Multilinguality}

[TODO: JJC]

The architecture described in section \ref{section:ACE_in_GF} not only supports
multilinguality but also makes implementing a new language in the grammar
relatively straight-forward provided that the language
is supported by the RGL. Adding a new language involves
implementing all the functions not present in \texttt{AttemptoI},
overriding the \texttt{AttemptoI} implementation for functions which would
otherwise deliver a semantically or pragmatically wrong linearization,
implementing the (small number of) operators that are not provided by the RGL,
and providing the domain vocabulary for the application.

It should be noted that some syntactic constructs, while described in the RGL,
are not implemented for all the languages (they are located in the RGL
Extra-modules). For our ACE implementation this is the case for VP coordination
which the RGL implements only for English and the Scandinavian languages.
This means that (ACE) sentences which feature VP coordination cannot be
translated into all the languages. An end-user application must therefore deal
with this issue, e.g. by asking the user to reformulate such sentences in a way
that preserves their meaning but uses a different syntactic form. For example,
VP coordination can be reformulated as relative clause coordination ---
`John owns a car or owns a bike' is in ACE equivalent to
`John is something that owns a car or that owns a bike'.

We included a number of different RGL-supported languages in the ACE-in-GF
implementation to discover the possible issues that a grammar engineer faces
when adding a new language. We also evaluated the resulting
translations for several of the included languages.
The currently included languages are
ACE,
Catalan,
Dutch,
English (almost identical to ACE),
Finnish,
French,
German,
Italian,
Spanish,
Swedish, and
Urdu.


\section{Evaluation}
\label{section:Evaluation}

In order to measure the quality of the grammar we can evaluate the following
properties.

\begin{description}
\item[Coverage]
i.e. how many syntactically correct ACE sentences does the grammar accept.
High coverage is required in applications which must translate a large variety
of ACE sentences. The goal is to have a 100\% coverage of the AceWiki subset.

\item[Ambiguity]
i.e. how many abstract trees are assigned on average to an accepted ACE
sentence. The goal is to parse each ACE sentence into to a single abstract
tree. However, some ambiguity can be tolerated if it is visible only internally,
it does not result in multiple different translations.

\item[Precision]
i.e. how many syntactically incorrect ACE sentences does the grammar generate.
Over-generation is especially undesired in the context of look-ahead editing
\cite{schwitter:eamt-claw2003}, where users would be exposed to
forms which the actual language does not support.

\item[Multilingual correctness]
i.e. do the translations of ACE sentences into other languages keep the
intended meaning of the original ACE sentences. Multilingual correctness allows
for knowledge engineering applications where users read and edit the underlying
knowledge base in multiple languages, understanding its content in the same
way regardless of the language.

\item[Performance]
i.e. how fast is the parser/linearizer. A certain speed is required to embed
parsing and linearization into a user interface component, e.g. a look-ahead
editor.
\end{description}

In the following we mainly measure the grammar against the existing
Codeco grammar, but sometimes also against the full ACE parser APE.

\subsection{Syntactic coverage}

In order to test the syntactic coverage of the GF implementation of the
AceWiki subset we have used the AceWiki Codeco test set which
is an exhaustive set of sentences with length of up to 10
tokens \cite{kuhn2010doctoralthesis}. Each word
type is represented by a single word (e.g. `Mary' represents the proper name)
to make sure that all the sentences are pairwise syntactically different, i.e.
do not differ only by choice of words.
The original testset contains 19718 sentences, but we removed sentences which
contain the `such that' construct which in ACE v6.6 is deprecated,
arriving at our test set of 19422 sentences.

[TODO: our implementation achieves X\% coverage, the remaining sentences
cannot be parsed because ...]

The AceWiki-specific implementation covers $\sim$50\% of full ACE, measured
on the $\sim$3000 sentences of the ACE parser (APE) regression test set.
(Note that these are sentences and text snippets manually collected over
several years, as APE does not support exhaustive generation.)

\subsection{Syntactic precision}

To test the precision (i.e. possible over-generation) we have used the
random generation facility of the GF commandline tool
(\verb!generate_random!). This allows us to randomly generate abstract trees
given the shape of the tree, its depth and its category. A resulting tree
can be then linearized as an ACE string which can be parsed with a
reference ACE parser.
This way of measuring precision is somewhat unnatural as one cannot gradually
go from shorter to longer sentences --- at relatively low depths the
sentences become already so long and complex that checking them for the
sources of errors becomes cumbersome.

We measured the precision by randomly generating large numbers of sentences
at different tree depths and parsing them with the full ACE parser (APE) and
the Codeco parser. As
a processing step after generation but before parsing we rewrote the sentences
to remove illegal anaphoric references as these are not
modeled in our grammar as discussed in section \ref{subsection:Codeco}.

Against full ACE the precision was about 90\% but against the AceWiki subset
the precision was drastically lower as the AceWiki subset sets several
restrictions on the sentence patterns that it supports, e.g. a negated
NP is not allowed in existential sentences (`there is nobody'),
an NP with a generalized quantifier cannot take a relative clause
(`less than 3 men that own a car`). The AceWiki subset also does not support
some variants (e.g. the contracted forms such as `isn't' and `doesn't').
We decided not to restrict our grammar in a similar fashion as this would
have caused a blowup of grammar rules. This relaxing of restrictions and
introduction of syntactic sugar which make our
implementation deviate from the AceWiki subset and move it towards full ACE
is often actually compatible with the subset of ACE that can be mapped to OWL
which is the main motivation of the AceWiki subset as well, i.e. some of
these constructs could be also added to the AceWiki subset.

[TODO: better motiviation needed]

%There are also
%places where the AceWiki subset could be extended (rather that its GF
%implementation restricted), e.g. AceWiki currently rejects ``every man
%likes less than 3 men that own a cat.'' because an NP with a
%generalized quantifier (less than 3) cannot be followed by a relative
%clause. But this sentence is supported by the ACE-OWL translator
%so there is no real reason why it should not be allowed in the
%AceWiki subset.

% AceWiki does support: ``... that Mary likes``
%Also, support for object relative clauses (``.. that Mary is mad-about'')
%is desirable (even though AceWiki does not completely support it).

% AceWiki does not support: who does Mary (not) like?
% (only: Mary likes (does not like) who?)

\subsection{Ambiguity}

We measured the occurrence of ambiguous parses also on the Codeco test set.
In rare cases (3\% of the sentences) the grammar assigns two abstract trees
to an input ACE sentence. This is always semantically harmless ambiguity
(i.e. it would not manifest itself in translations) resulting from the rules
for common nouns and noun phrases which accept similar input structures.

[TODO: analyze better the reasons for ambiguity,
most of it seems to be spurious ambiguity,
but there are also cases like
``for every  woman  there is  somebody  and  there is  somebody  .'',
the Codeco testset might also be too small to reveal certain kinds of
ambiguities.]


\subsection{Multilinguality}

To test the correctness of the multilingual translations we have used
the ACE sentences from the
Ontograph
Framework\footnote{\url{http://attempto.ifi.uzh.ch/site/docs/ontograph/}}
\cite{kuhn2009cnlmain}. The selected 40 sentences cover all the main sentence
patters of the AceWiki subset and have been used before in user
evaluations of how well the users understand the precise formal meaning ACE.
The sentences have a very clear set-theoretic meaning, e.g.
``Everything that is a traveler or that is an officer sees
at most 1 aquarium.'' means that the union of the sets \emph{traveler} and
\emph{officer} is a subset of the set of all instances that participate in
the 1st argument position in at most one \emph{sees}-relation with an
instance from the set \emph{aquarium}.
The hypothesis to be confirmed is whether this meaning is understood in
the same way via all the languages.

While the tests of coverage and precision can be automated, the test of
multilingual correctness requires that (native) speakers of the evaluated
languages manually check the translations. We set up a Google Docs form that
presents the list of 40 sentences each translated into 9 languages
(Catalan, Dutch, Finnish, French, German, Italian, Spanish, Swedish and Urdu),
and asked native speakers of these languages to check the list and report
the syntactic, semantic and pragmatic (naturalness) errors in the sentences.
In order to judge the semantic correctness of the translations, the
evaluator must also consider the original ACE sentence. The evaluation form
therefore comes with a short description of ACE and its interpretation rules
that are relevant for the presented sentences.
The evaluators were also asked to ignore the lack of translations caused by
the missing support for VP coordination.

[TODO: JJS: write about the results and
interesting examples where the straight-forward translation produces
a completely different meaning]

%[TODO: the Ontograph test set does not cover some core ACE equivalences,
%e.g. \emph{if-then} equals \emph{every}, double negation equals no negation.
%How are these equivalences preserved under the direct syntax-based
%translation?]

\subsection{Performance}

We measured the performance of the grammar implementation on an i3 laptop
with 4GB of RAM.
The implementation is relatively fast. It is capable of parsing
all the $\sim$20,000 Codeco test sentences in 55 seconds
(i.e. 363 sentences/sec). In comparison, the Codeco parser (transformed into
Definite Clause Grammar and executed by SWI-Prolog) parses
the same set in 25 seconds.
In order to linearize the
resulting parse trees into 8 languages an additional 9 minutes is needed
(Note that we did not measure what was
the contribution of each language to the overall runtime.)
In general,
the measured performance enables applications where a relatively large ACE
knowledge base is stored as a set of GF abstract trees and linearized into a
multilingual presentation on demand in a few minutes.

\section{Conclusions and future work}
\label{section:Conclusions}

We have presented a set of GF grammar modules that implement the AceWiki
subset of ACE and make it available in multiple natural languages. The design
of the grammar makes it easily extendable to more languages and to a larger
coverage of ACE.
We have also described the main differences between the grammar formalisms
used to describe the ACE grammar so far and the GF formalism.
These differences make the grammar engineering non-trivial and a fully
precise grammar cannot be easily obtained.
We have also described a testing and evaluation framework that can be used
during and after the development.

Future work includes plugging in new languages as support for them becomes
available in the RGL as well as adding more ACE constructs. We also plan
to use the developed grammar as a module in the AceWiki semantic wiki system
to power the look-ahead editor and offer multilingual viewing and editing
of the wiki content. Using the grammar in an actual application also offers
new ways to evaluate the notion of multilingual controlled natural language.

\bibliography{bib}
\bibliographystyle{alpha}
%\bibliographystyle{plain}

\end{document}

% Recycle Bin follows
\begin{itemize}
\item ACE is written in the unification style vs. GF grammar is written
by separating the abstract syntax from the concrete
\item ACE offers support for anaphoric references (a feature present in most
logical rule and ontology languages) vs. GF does not provide similar support
\end{itemize}
