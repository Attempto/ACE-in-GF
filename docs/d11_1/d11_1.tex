\documentclass[a4paper]{article}

\usepackage[pdftex]{graphicx}
\usepackage{a4wide}
\usepackage{hyperref}
\usepackage{times}

% TODO: get UTF to work in biblio (Normunds' citation)
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}

\graphicspath{{./images/}}

\def\uid#1{\texttt{#1}}
\def\xp#1{\texttt{#1}}
\newcommand\ace{Attempto Controlled English}

\begin{document}
\title{Attempto Controlled English in Grammatical Framework}
\author{DRAFT}

\hyphenation{alpha-numeric}
\hyphenation{ex-pe-ri-ment-al}

\maketitle
\begin{abstract}
This report describes the implementation of a large part of the
Attempto Controlled English (ACE) syntax ---
the subset of ACE that is accepted by AceWiki ---
in Grammatical Framework (GF) and making it available via [TODO: 10]
languages that are supported by the GF Resource Grammar Library (RGL).
The main goal of this work is to make ACE available in multiple languages
in order to allow
ACE-based knowledge representation also in languages other than English.
Additionally, having a GF implementation of the ACE language would provide
ACE users with new (GF-based) editing tools.
\end{abstract}

\section{Introduction}

\ace{} (ACE) \cite{fuchs:reasoningweb2008}
is a general purpose
first-order language (FOL)
with English syntax,
i.e. ACE can be viewed as both a natural language understandable by every
English speaker, as well as a formal language with a precisely defined
syntax and semantics understandable by automatic theorem proving software.
ACE texts are deterministically interpreted
via Discourse Representation Structures \cite{kamp:drt1993}.
The syntactically legal sentence structures and their
unambiguous interpretation is explained in the end-user documentation of
\emph{construction} and \emph{interpretation} rules.
The ACE toolchain includes a parser that maps ACE sentences into a concrete
DRS form \cite{ifi-2010.0010} and further into formats supported by existing
automatic reasoners (e.g. OWL, SWRL, TPTP).

The current version of ACE, version 6.6, offers many language constructs, most
important of which are
countable and mass nouns;
proper names;
generalized quantifiers (e.g. `at least');
indefinite pronouns (e.g. `somebody');
intransitive, transitive and ditransitive verbs;
negation, conjunction and disjunction of
noun phrases, verb phrases, relative clauses and sentences;
and anaphoric references to noun phrases through proper names,
definite noun phrases, pronouns, and variables.
End-users working with ACE can specify a lexicon that maps English
wordforms of nouns, verbs, adjectives and adverbs into logical atoms,
which the users
can interpret as they wish, but otherwise the ACE grammar or its mapping to
DRS cannot be changed.

Grammatical Framework (GF) \cite{ranta:book2011}
is a framework for defining multilingual grammars.
GF provides a functional programming language in which
the grammar author implements an abstract syntax and its corresponding
concrete syntaxes and by doing that
describes a bidirectional mapping between concrete language strings and
their corresponding abstract syntax trees. This architecture supports
multilingual translation as strings of any concrete language can be parsed into
abstract trees which can be further linearized as strings in any concrete
language.

GF is optimized to handle natural language features like morphological
variation, agreement, long-distance dependencies, etc.
GF comes with various tools that
cover grammar authoring, compatibility with many popular programming languages,
conversion into other grammar formats, and a reusable grammar library covering
many world natural languages and providing a language-neutral API to a large
number of linguistic categories (e.g. NP, VP) and constructs
(e.g. combination of NP and VP into a sentence).

The purpose of this report is to study whether it is possible and useful to
implement the grammar of ACE in GF, with the main goal of turning ACE into
a multilingual controlled natural language (CNL).
In section \ref{section:Goals_and_requirements} we describe the goals of the
GF-based implementation of ACE;
in section \ref{section:Existing_work} we point out existing implementations;
in section \ref{section:Implementing_ACE_in_GF} we describe our implementation;
in section \ref{section:Multilinguality} we describe the novelty of this work,
namely multilinguality;
in section \ref{section:Evaluation} we evaluate the implementation by comparing
it to existing implementations of the ACE grammar;
in section \ref{section:Future_work} we describe possible extensions to this
work.

The developed grammar as well as the test sets, development tools and
documentation are available under the LGPL license on the GitHub repository

\begin{quote}
\url{https://github.com/Attempto/ACE-in-GF}
\end{quote}

\section{Goals and requirements}
\label{section:Goals_and_requirements}

The overall goal of this work is to make ACE available to users who have little
English skills by turning ACE-based systems like
AceWiki \cite{kuhn2010doctoralthesis} multilingual. This allows users
to create and consume content whose native format is a formal language
(specifically a FOL-based language) in multiple natural languages
via an ACE-based interlingua (see figure \ref{fig:languages}).
Also, having a GF implementation of the ACE language would
provide ACE users with new (editing) tools that are based on the GF technology,
offering e.g. look-ahead editing, embeddable grammars, conversion into
speech recognition grammar formats, etc.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{languages}
\caption[Languages]
{Bidirectional mapping between a formal language like OWL and a natural
language like Finnish facilitated by the multilingual GF-implementation of
ACE and various mappings between ACE and other formal languages.}
\label{fig:languages}
\end{figure}

Our main research questions are:

\begin{itemize}
\item what are the features and benefits of a general purpose multilingual
controlled natural language?
\item is it technically possible to implement the ACE syntax in GF,
and what are the benefits of such an implementation?
\end{itemize}

Our goal is to demonstrate that a large fragment of the ACE syntax
can be implemented in a language-neutral way and ported to a large number
of different natural languages. This involves showing that

\begin{itemize}
\item extending and modifying the grammar to reflect possible
changes in the ACE specification is straight-forward;
\item multilingual translations of the same abstract tree preserve the precise
and unambiguous meaning assigned to the ACE sentences;
\item adding support for new languages is straight-forward.
\end{itemize}

Note that this report describes the implementation of the ACE syntax,
i.e. not its DRS mapping. Therefore most usages of the resulting GF grammar
will have to combine it with the existing ACE parser, which provides the
mapping to DRS and further into other logical forms (including a verbalization
back into ACE which can be used to paraphrase the original text).


\section{Existing work}
\label{section:Existing_work}

Our work builds on \cite{ranta:cnl2009_revised} which implements the syntax
of ACE v6.0 (by following \cite{ACE_6.0_Construction_Rules}) and makes it
available in 7 languages (English, French, German, Italian, Swedish, Finnish
and Urdu) via the GF Resource Grammar Library (RGL) \cite{ranta:lilt2009}.
Our goal is to update this implementation to ACE v6.6, make it precisely
cover a large subset of ACE, and increase the number of natural languages to
which the grammar is ported.

Another existing work that implements ACE in GF is
``ACE compliant controlled Latvian for ontology authoring and verbalization''
\footnote{\url{http://valoda.ailab.lv/cnl/}}
\cite{gruzitis:phd}. The goal of this work is to bidirectionally map Latvian
language sentences to OWL axioms and queries. The developed system
does not expose ACE to the end-user and only treats it as a
machine-readable intermediate format that provides access to the ACE tools
(specifically the bidirectional OWL converter).
It therefore does not have to deal with the
generation of correct ACE wordforms.
The system is also not built with multilinguality in mind
(i.e. it does not use the general GF RGL APIs). It thus cannot serve easily as
a starting point of the work described in this document.


\section{Implementing ACE in GF}
\label{section:Implementing_ACE_in_GF}

Rather than directly building a grammar for the
full ACE v6.6\cite{ACE_6.6_Construction_Rules}, we chose to focus
on the subset of ACE that is used by the AceWiki semantic wiki system. The
resulting grammar can be seen as a core module which can be used by AceWiki
without any change and which can be extended by a separate grammar
towards full ACE as need arises. The AceWiki subset is a relatively expressive
fragment of ACE, roughly matching the expressivity of the OWL ontology
language
\cite{OWL_2_Web_Ontology_Language_Document_Overview}
without data properties.
This makes the subset relevant in (Semantic Web) ontology editing applications.
The other benefit of the AceWiki subset is that it is formally defined by a
Codeco grammar \cite{kuhn:cnl2010_revised}
\footnote{\url{http://attempto.ifi.uzh.ch/site/docs/acewikijava/ch/uzh/ifi/attempto/acewiki/aceowl/acewiki_grammar.html}},
which provides both parsing and generation and thus gives us an excellent
reference implementation against which we can easily test our GF-based
implementation.
With Codeco we can perform exhaustive generation of syntactically legal
sentences. Also the Codeco grammar can be used to implement look-ahead
editors, similarly to GF, which provides for us another point of comparison.

\subsection{Codeco}

Codeco is a unification grammar formalism with special support for describing
anaphoric references. For example, the following (simplified)
rules declare that a simple
sentence can be formed by `there is' followed by
a noun phrase (NP) that is further restricted by the binary features of
plurality, definiteness and existential quantification.
A definite noun phrase (\verb!np[def:+]!) can be formed by prefixing
a noun with `the'. Such a noun phrase
must refer to a preceding (\verb!<!) noun phrase and can be referred to by a
following (\verb!>!) noun phrase provided that the feature structures
unify, e.g. nouns in the noun phrases match.
The definite NP cannot be used after `there is' because the
declared features \verb!def:+! and \verb!def:-! do not unify.

\small
\begin{quote}
\begin{verbatim}
simple_sentence => 'there is' np[pl:-, def:-, exist:+]
np[def:+] => 'the' noun[noun:Noun] <[type:noun, noun:Noun] >[type:ref]
\end{verbatim}
\end{quote}
\normalsize

As GF does not directly provide support for unification-based rules nor
declarative implementation of anaphoric references, we cannot directly map
the Codeco rules to corresponding GF rules.
In fact, due to the lack of support for
anaphoric references in GF we will not try to precisely model this aspect of
ACE, i.e. our GF grammar will over-generate in the sense that it will allow
impossible anaphoric references (`The man likes Mary.').

[TODO: go over the Codeco features and see what corresponds to them
in GF, if it should belong to the concrete or the abstract part.]

\subsection{Structure}

Closely following the original implementation in \cite{ranta:cnl2009_revised},
the multilingual ACE grammar is implemented in GF as a set of modules
(see figure \ref{fig:modules}) the most important of which are:

\begin{itemize}
\item abstract syntax \texttt{Attempto} which defines the ACE syntax as
a set of $\sim$100 language-independent functions
(e.g. \verb!everyNP : CN -> NP!)
that operate on language-independent categories (\texttt{CN}, \texttt{NP});
\item incomplete concrete syntax \texttt{AttemptoI} which uses the GF RGL
to provide concrete linearizations for the abstract functions. This module
is language-independent in the sense that the linearizations are provided
via the RGL API which is common to all the languages that are supported by the
RGL;
\item (complete) concrete syntax \texttt{Attempto\textit{Lan}}, where
\textit{Lan} is a 3-letter language code of the concrete language. This
module instantiates \texttt{AttemptoI} with the concrete language, but
additionally offers the possibility of language-specific fine-tuning of the
linearizations assigned by \texttt{AttemptoI} or the implementation of
linearizations that are not given in \texttt{AttemptoI}.
\end{itemize}

This architecture makes it easy to plug in support for new languages ---
one only needs to implement \texttt{Attempto\textit{Lan}} for the new language
\textit{Lan}. If the new language has RGL support and \texttt{AttemptoI}
already provides most of the implementation, then
the new module \texttt{Attempto\textit{Lan}} will be just a couple of lines
long.


\begin{figure}[ht]
\centering
\includegraphics[width=0.99\textwidth]{modules}
\caption[Relations between the ACE grammar modules]
{Relations between the modules, using German (Ger) as an example
of one of the many concrete languages. To add support for a new language,
e.g. Dutch, one must implement three files:
\texttt{AttemptoDut}, which just
instantiates the functor \texttt{AttemptoI} with Dutch-specific resources
from the RGL;
\texttt{TestAttemptoDut}, which contains the domain lexicon; and
\texttt{LexAttemptoDut}, which implements the Dutch-specific resources that
do not come from the RGL. The implementation of the lexicon can also
rely on the resources (Dutch morphological paradigms) implemented
in the RGL.}
\label{fig:modules}
\end{figure}

\subsection{Lexicon}

ACE makes a clear separation of lexicon and the rest of the syntax. The ACE
lexicon is a simple mapping of word forms to their corresponding lemmas, which
can be easily added and redefined by the users
\cite{ACE_6.6_Lexicon_Specification}. While the full ACE knows 27 types of
word forms (singular common noun, transitive verb, ...), the AceWiki subset
uses a smaller but also a slightly different set of lexical categories.

\begin{itemize}
\item proper name (with possible abbreviation and \emph{the}-prefix)
\item common noun (with singular and plural form)
\item noun in an \emph{of}-construct (e.g. `part', `child')
\item transitive verb (with 3rd singular, bare infinitive and past participle
forms)
\item transitive adjective (e.g. `fond of')
\end{itemize}

GF does not make a clear separation between words and the rest of the grammar.
Furthermore, words can be described by complex structures holding information
about their gender, case, discontinuity, depending on the language. Most of
this necessary complexity is hidden by the RGL, which operates with common
lexical categories (e.g. \texttt{PN}, \texttt{V2}) and common constructors
(e.g. \texttt{mkN} takes two strings as arguments, for the singular and plural
forms of the noun, an guesses the missing information (e.g. gender).
Most of the ACE lexical categories are supported by the RGL and the internal
repsentations of words can be generated using RGL operators.
Table \ref{mapping_acewiki_to_gf} shows the mapping of AceWiki categories
to GF RGL English operators.
[TODO: we have to ignore certain things, e.g.  the the-PNs?]

\begin{table}
\begin{center}
\caption{Mapping of AceWiki lexical categories
to GF RGL API categories and GF English
morphological paradigms. Underscore marks the ommision of wordforms that
cannot occur in ACE but that are required by the GF RGL
operator.\protect\label{mapping_acewiki_to_gf}}
\begin{tabular}{ l l l }
\hline
AceWiki category & GF Cat & GF Eng oper \\
\hline
proper name & PN & \xp{mkPN john} \\
common noun & CN & \xp{mkCN (mkN sg pl)} \\
relational noun & CN & \xp{mkCN (mkN sg \_)} \\
transitive verb & V2 & \xp{mkV2 (mkV go goes \_ gone \_)} \\
transitive adjective & A2 & \xp{mkA2 (mkA fond) (mkPrep of)} \\
\hline
\end{tabular}
\end{center}
\end{table}

%Mapping the ACE lexical categories to GF RGL categories and morphological
%paradigms.
%[TODO: discuss variation]
%
%Table \ref{mapping_clex_to_gf} shows the mapping.
%
%\begin{table}
%\begin{center}
%\caption{Mapping of Clex to GF\protect\label{mapping_clex_to_gf}}
%\begin{tabular}{ r l l }
%\hline
%Clex & Cat & GF oper \\
%\hline
%\xp{noun\_mass} & MCN & \xp{mkCN (mkN ... (mkN ...))} \\
%\hline
%\end{tabular}
%\end{center}
%\end{table}

\subsection{Summary}

Mapping an ACE grammar (such as the one described by Codeco) to a GF grammar
is non-trivial for the following reasons.

\begin{itemize}
\item ACE is written in the unification style vs. GF grammar is written
by separating the abstract syntax from the concrete
\item ACE offers support for anaphoric references (a feature present in most
logical rule and ontology languages) vs. GF does not provide similar support
\end{itemize}

\section{Multilinguality}
\label{section:Multilinguality}

The architecture described in the previous section makes adding support
for a new language relatively straight-forward provided that the language
is supported by the RGL. Adding a new language involves
implementing all the functions not present in \texttt{AttemptoI},
overriding the \texttt{AttemptoI} implementation for functions which would
otherwise deliver a semantically or pragmatically wrong linearization,
implementing the (small number of) operators that are not provided by the RGL,
and providing the domain vocabulary for the application.

We selected a number of RGL-supported languages to evaluate how easy it
is to add a new language in practice and to evaluate the feasability of
representing the language ACE in a language other than ACE. The chosen
languages are
English, German, Finnish, Urdu, Italian, French, Swedish, Dutch
(, Hindi, Spanish, Catalan?). [TODO: why these languages]

\subsection{ACE}

ACE was implemented by extending the English resource grammar but
overriding some of its constructs and adding some variants.

Does it make sense to treat ACE and English as separate languages in the
grammar, and expose them as different languages to the end user?

\subsection{Main issues}

[TODO: currently copied from \cite{ranta:cnl2009_revised}]
The translation from one language to another using the abstract syntax of the
resource grammar preserves syntactic structure. But it does not always give
the intended result. [TODO: ACE-specific example]
Thus the resource grammar should rather be used as a \emph{library} for
defining the domain grammar. In those cases where direct syntax-based
translation still works (which in practice does cover most cases), a lot of
work can be saved, because the linearization function for a given abstract
function can then be defined once and for all using the language-independent
API of the resource library. Some exceptions to this can then be done for
those languages that do not preserve syntactic structure in translation,
but still using the library. [TODO: example]

Some issues: RGL does not provide some functions for all the languages,
e.g. VP coordination.

\section{Evaluation}
\label{section:Evaluation}

To test the coverage and performance of the GF implementation of the
AceWiki subset we have used
the AceWiki Codeco test set which
is an exhaustive set of sentences with length of up to 10 tokens.
The original testset contains 19718 sentences, we removed sentences which
contain the `such that' construction which was deprecated in a recent
version of ACE, arriving at our test set of 19422.

To test the precision (i.e. possible over-generation) we have used GF's
random generation facility.

To test the correctness of the multilingual translations we have used
the sentences from the
Ontograph
Framework\footnote{\url{http://attempto.ifi.uzh.ch/site/docs/ontograph/}}
\cite{kuhn2009cnlmain}. These sentences cover all the main sentence
patters of the AceWiki subset and they have been used before in user
evaluations of how well the users understand the precise formal meaning
of the sentences.
These 40 sentences cover all the main AceWiki sentence patterns and have
a very clear set-theoretic meaning, e.g.
``Everything that is a traveler or that is an officer sees
at most 1 aquarium.'' means that the union of the sets \emph{traveler} and
\emph{officer} is a subset of the set of all instances that participate in
the 1st argument position in at most one \emph{sees}-relation with an
instance from the set \emph{aquarium}.
The question is if this meaning is understood in the same way via all the
languages.

\subsection{Syntactic coverage}


\subsection{Syntactic precision}

Over-generation is especially undesired in the context of look-ahead editing
\cite{schwitter:eamt-claw2003}, where users would be exposed to
forms which the actual language does not support.

Legal uses of definite NPs cannot be (easily) described in GF, e.g. GF
allows both ``every man likes the man'' and ``every man likes the woman'',
while AceWiki ACE OWL (as implemented in Codeco) allows only the
first one.

[TODO: other interesting cases?]

There are also
places where the AceWiki subset could be extended (rather that its GF
implementation restricted), e.g. AceWiki currently rejects ``every man
likes less than 3 men that own a cat.'' because an NP with a
generalized quantifier (less than 3) cannot be followed by a relative
clause. But this sentence is supported by the ACE-OWL translator
so there is no real reason why it should not be allowed in the
AceWiki subset.

% AceWiki does support: ``... that Mary likes``
Also, support for object relative clauses (``.. that Mary is mad-about'')
is desirable (even though AceWiki does not completely support it).

% AceWiki does not support: who does Mary (not) like?
% (only: Mary likes (does not like) who?)

\subsection{Ambiguity}

[TODO: does the grammar sometimes assign multiple trees to a sentence?]

\subsection{Multilinguality}

[TODO: We did a closer evaluation of 7 languages.]

[TODO: VPCoord is not supported in all languages]

[TODO: interesting examples where the straight-forward translation produces
a completely different meaning]

[TODO: the OntoGraph test set does not cover some core ACE equivalences,
e.g. \emph{if-then} equals \emph{every}, double negation equals no negation.
How are these equivalences preserved under the direct syntax-based
translation?]

\subsection{Performance}

We measured the performance of the grammar implementation on an i3 laptop
with 4GB of RAM.
The implementation is relatively fast. It is capable of parsing
all the $\sim$20,000 Codeco test sentences in 55 seconds
(i.e. 363 sentences/sec). In comparison, the Codeco DCG implementation parses
the same set in 25 seconds.
In order to linearize the
resulting parse trees into 8 languages an additional 9 minutes is needed
(Note that we did not measure what was
the contribution of each language to the overall runtime.)
Such performance enables applications where a relatively large ACE knowledge
base is stored as a set of GF abstract trees and linearized into a
multilingual presentation on demand in a few minutes.


\section{Future work}
\label{section:Future_work}

In the
future, one might want to extend the implementation (using
the standard GF extension mechanism) to also cover full ACE.

\bibliography{bib}
\bibliographystyle{alpha}
%\bibliographystyle{plain}

\end{document}
